# 重写和重载

## 字面描述
* 子类```重写```继承自父类的方法
* 子类```重载```一个方法的参数格式

## 对比

| 名称   | 参数    | 返回值    | 访问修饰符  | 异常                   | 是否可以在同一个类 | 是否依赖继承 | 执行阶段    |
|------|-------|--------|--------|----------------------|-----------|--------|---------|
| 方法重写 | 相同    | 相同     | 大于等于父类 | 比父类的异常更有限,或者子类就不抛出异常 | 不可以       | 依赖     | 编译期,有多态 |
| 方法重载 | 参数不相同 | 返回值无限制 | 无限制    |     无限制                 | 可以        | 不依赖    | 执行器,无多态 |

## 示例
~~~java
public class Exception_1 extends RuntimeException{
}
~~~
~~~java
public class Exception_2 extends Exception_1{
}
~~~
~~~java
public class Parent {

    protected void run() throws Exception_2 {

    }

    /**
     * 这里是重载了方法run的参数和返回值
     * @param i
     * @return
     */
    public int run(int i){
        return 1;
    }

    private void run(String i){

    }
}
~~~

~~~java

public class Son1 extends Parent{


    /**
     * 访问修饰符需要大于等于父类
     * 但是抛出的异常粒度要比父类更小,或者是父类异常的子类,或者不抛出异常
     * @throws Exception_2
     */
    @Override
    public void run() throws Exception_2 {
        System.out.println("1");
    }

    public static void main(String[] args) {
        Parent son1 = new Son1();
        son1.run();
    }
}
~~~


## 归纳总结

~~~text
对于重写
指的是重写继承自父类的方法,但是参数和返回值的要求比较严格.必须相同
且因为开闭原则,子类这里是对拓展开放的,所以访问修饰符的权限可以比父类高.方便拓展后被访问
但是因为异常相关的信息是定义上的,所以不可以被修改,只能小于等于父类的异常限制

对于重载
指的是重载当前类某个方法的参数和返回值,侧重的不是定义,只是方法意义上的同名
~~~