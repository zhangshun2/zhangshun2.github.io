# 面向对象的五个原则

这里的说法其实概念和表达的意图并不是很贴切

## 意图
* 接口和类的功能更单一,粒度切分到最小,切分到一,这样可以让问题的发现更简单
  * 同时降低类的耦合程度
    * 假设一个接口实现了多个功能,再去调用的时候这里的功能又和别的多个功能那在一起了,耦合会越来越严重
* 模块之前的耦合控制依赖于抽象,只保证所有的具体依赖于抽象,而不是具体依赖于具体等等
  * 只有这样才能保证模块之前的耦合更小
* 从功能上而言,类的本身要本身java的设计理念,即java的三个特性,(抽象),封装,继承,多态
  * 继承这里就提出了明确要求,子类要能平替其继承的父类.如果只是拓展肯定没问题,如果是修改这里就无法平替父类了

> 所以这里可以有新的总结

### 单一性要求(多态在子类上的要求)
* 接口功能单一(接口隔离原则)
* 类功能单一(单一职责原则)

### 封装特性要求
* 依赖于抽象(依赖倒置原则)

### 继承特性要求
* 对拓展开放对修改关闭(开闭原则)
* 子类可以替代其基类正常运行(里氏替换原则)


## 特例
~~~text
有一些情况是有可能违反基础的设计原则的
因为社群环境的隔离,和对于某一个模块的依赖
假设某个开源代码出现了问题,这里仅有一个小地方出现了问题
但是涉及的使用方很多,让所有的业务方平替掉这个引用的成本很高
(如果多个开发部分整体管理方便可以直接平替引用深夜升级)
且因为大量的属性和方法权限封闭,无法用复合和转发的方式处理掉
这时候为了迅速解决问题
    创建一个与出现问题的类的包名一致的包名,再去复制这个类,并对这个类进行复合操作,
    所有的操作类在复合中执行,同时修改掉复制类的错误代码,
    等到错误的类的代码修改之后,删除掉这个复制类即可,复合类可以继续调用
    
    原理: 由于类加载机制,最先加载的是引用的引用,其实是加载引用,最后才会加载当前代码.如果加载的
    目录相同,则字节码文件会被覆盖.
    通过覆盖字节码的方法临时修改上层引用bug,并用复合类进行调用.这时候的复合类是为了明确调用方,
    如果正常使用的时候就是复合和转发的就没有必要再去单独写了
~~~
