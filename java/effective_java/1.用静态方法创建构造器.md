# 用静态工厂方法创建构造器

## 使用原因

### 可以有名称
~~~text
很直观的通过名称得知用途
~~~

### 可以预先创建对象
~~~text
不用每次使用方法的时候都创建一个新对象
适用于需要使用一个可复用对象的场景
或者一些final类中
~~~

### 可以返回原对象的任意子类
~~~text
在功能上更为灵活
比如指定参数来返回对应的子类
~~~
### 可以返回某个接口
~~~text
返回的对象并不一定存在,可以指定返回某个接口
~~~

## 说明
~~~text
区别于公有或者私有的构造器
静态工厂创建的构造器,更适用于复用,而不是适用于继承

#### 示例代码
~~~java
public class DemoProject {

    private static Map<Integer  , DemoProject> map = new HashMap<>(10);

    private  Map<Integer  , DemoProject> usualMap = new HashMap<>(3);

    static {
        map.put(1,new DemoProject());
        map.put(2,new DemoProjectSubClass1());
        map.put(3,new DemoProjectSubClass2());
    }

    {
        if (null != usualMap && usualMap.size() > 3) {

            if (null == usualMap.get(1)){
                usualMap.put(1,new DemoProject());
            }

            if (null == usualMaoGet(2)){
                usualMap.put(2,new DemoProjectSubClass1());
            }

            if (null == usualMaoGet(3)){
                usualMap.put(3,new DemoProjectSubClass2());
            }
        }

    }

    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public DemoProject() {
    }

    public DemoProject(String name) {
        this.name = name;
    }

    /**
     * 例子在这里
     * @param key 参数值
     * @return 根据参数返回不同的子类
     */
    public static DemoProject defaultOf(Integer key){
        if (key>=1 && key <=3){
            return map.get(key);
        }
        return map.get(1);
    }

    public  DemoProject usualMaoGet(Integer key){
        if (key>=1 && key <=3){
            return usualMap.get(key);
        }
        return usualMap.get(1);
    }

    @Override
    public String toString() {
        return "DemoProject{" +
                "name='" + name + '\'' +
                '}';
    }
}
~~~
