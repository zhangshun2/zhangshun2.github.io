# builder模式
----
## 使用原因

* 对于常规的构造器而言,参数越多, <br>需要声明的构造器越多或者需要一直维护.相对而言耗时耗力
* 另一种方式是类只提供默认无参构造的方式,全部通过set来赋值,这种方式叫做javaBeans方式
  * 多线程操作的时候无法保证线程的安全

## 参照
~~~text
用过lombok的应该队builder模式有体会
~~~

## 具体操作

### 类级别
~~~text
内部声明一个公共的静态类
静态类提供一个链条方式的方法
当前类提供一个用builder生成当前类示例的方法
~~~

比如
~~~java
/**
 * java在 类存在多个参数,且参数后续会不断参加的情况下
 *
 * 会使用多参数构造器
 * 但是后面需要一直维护
 *
 * 或者默认无参数然后使用set的方式,但是使用set的时候无法确保线程安全,这样的情况下对象在set值的时候可能出现前后不一致的情况
 * 这种模式叫javaBeans模式,是不安全的.
 * 主要原因: 多线程的时候无法绝对保证set和get的顺序.可能get值的时候set还没有结束
 *
 * 所以这里就常话不说了,还是构造器模式,常见用法可以参考于lombok
 */
public class BuildDemo {

    private String name;

    private int age;

    public static class Builder{

        private String name;

        private int age;

        public Builder() {
        }

        public Builder(String name) {
            this.name = name;
        }

        public   Builder Builder(String name){
            this.name = name;
            return this;
        }

        public Builder age(int age){
            this.age =  age;
            return this;
        }

        public BuildDemo build(){
            return new BuildDemo(this);
        }


    }

    public BuildDemo() {
    }

    public BuildDemo(Builder builder) {
        this.name = builder.name;
        this.age = builder.age;
    }

    public static void main(String[] args) {

        BuildDemo demo = new Builder("name1").age(1).build();

    }
}
~~~
### 抽象类级别
> 声明一个抽象静态内部类,对链式实现抽象,可以对于公共的链式部分写出具体实现

示例代码如下

带有抽象内部类的
~~~java
/**
 * 这里演示抽象类和抽象类的实现类的builder模式的实现
 *
 */
public class Pizza {

    public enum Topping {
        HUM,
        MUSHROOM,
        ONION,
        PEPPER,
        SAUSAGE
    }

    /**
     * 复习: final 修饰属性时
     *  如果是基本属性,是不变的
     *  如果是对象类型,只允许初始化一次,第一次初始化之后引用地址不变
     *  同样在方法的参数上同理
     *
     *  修饰方法是代表方法不能被重写,子类正常使用之类的不影响
     *  修饰类的时候代表类不可以被继承,这个类已经很完美了
     */
    final Set<Topping> toppings;

    /**
     * 泛型相关的要么是接口要么是抽象类好点,因为部分定义不用写出具体的方法体
     * @param <T>
     */
    abstract static class Builder<T extends Builder<T>> {

        EnumSet<Topping> toppings = EnumSet.noneOf(Topping.class);

        public T addTopping(Topping topping) {
            toppings.add(Objects.requireNonNull(topping));
            return self();
        }

        /**
         * 试试这种写法
         * 事实证明不行,返回值要么是有对应值的方法,要么是个被具体初始化的T,这里要这么写T就必须是一个具体的内容,就市区了抽象的意义
         */
       /* public T addTopping2(Topping topping) {
            toppings.add(Objects.requireNonNull(topping));
            return T;
        }*/

        /**
         * 这里用一个抽象方法来表明链条的构造过程,T表示当前对象
         * @return
         */
        protected abstract T self();

        abstract Pizza build();
    }

    Pizza(Builder<?> builder){
        toppings = builder.toppings.clone();
    }


    /**
     * 最后来整理思路:
     * 类自身可以有一个未初始化的值域.写入和读取都走这个值域
     *
     * 而写入的过程可以通过一个抽象静态内部类来实现
     * 抽象是因为泛型T不好具体初始化
     * 静态是以为内部需要调用,所以这种时候对于泛型使用初始胡的过程的时候内部是一个抽象静态内部类
     *
     * 简单概述,通过静态内部类的方法构成链,在复制给类的属性构造成对象
     */

    /*public static void main(String[] args) {

        Builder builder = new Builder() {
            @Override
            protected Builder self() {
                return (Builder) new Object();
            }
        }.addTopping(Topping.HUM).addTopping(Topping.ONION);
        Pizza abstractBuild = new Pizza(builder);
        abstractBuild.toppings.stream().forEach(System.out::println);

    }*/
}
~~~

相关的链式实现
~~~java
/**
 * 这时候我们完成了第一个子类的所谓的构造,这里演示一个基础的方法
 */
public class ApplePizza extends Pizza{

    public static class Builder extends Pizza.Builder{

        @Override
        protected Pizza.Builder self() {
            return this;
        }

        @Override
        Pizza build() {
            return new ApplePizza(this);
        }


    }


    ApplePizza(Builder builder) {
        super(builder);
    }



    public static void main(String[] args) {
        Pizza build = new Builder().addTopping(Topping.MUSHROOM).build();
    }
}
~~~

> 如上的好处.可以将公共的链条和子类的链条区分开

